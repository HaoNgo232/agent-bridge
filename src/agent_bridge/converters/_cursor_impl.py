"""
Cursor AI Converter
Converts Antigravity Kit agents/skills to Cursor format.

Output structure:
- .cursor/agents/*.md (agent files)
- .cursor/rules/*.mdc (rules with MDC frontmatter)
- .cursor/skills/*.md (merged skill files)
- .cursor/mcp.json (MCP configuration)

Reference: https://cursor.com/docs/context/rules
MDC Format: description, globs, alwaysApply frontmatter
"""

import re
import shutil
from pathlib import Path
from typing import Any, Dict

import yaml

# Credit line appended to generated files. Set to "" to disable.
CREDIT_LINE = "\n\n---\n*Generated by [Agent Bridge](https://github.com/HaoNgo232/agent-bridge)*\n"


# =============================================================================
# MDC FRONTMATTER CONFIGURATION
# =============================================================================

# MDC RULES: Auto-activation based on file matching (Globs)
MDC_RULES_CONFIG = {
    "clean-code": {"alwaysApply": True, "globs": "", "description": "Core coding standards"},
    "behavioral-modes": {"alwaysApply": True, "globs": "", "description": "Agent behavioral guidelines"},
    "nextjs-react-expert": {
        "alwaysApply": False,
        "globs": "**/*.tsx,**/*.jsx,**/next.config.*,**/app/**/*,**/pages/**/*",
        "description": "Next.js and React expertise",
    },
    "tailwind-patterns": {
        "alwaysApply": False,
        "globs": "**/*.tsx,**/*.jsx,**/*.css,**/tailwind.config.*",
        "description": "Tailwind CSS styling patterns",
    },
    "typescript-patterns": {
        "alwaysApply": False,
        "globs": "**/*.ts,**/*.tsx,**/tsconfig.json",
        "description": "TypeScript language standards",
    },
    "python-patterns": {
        "alwaysApply": False,
        "globs": "**/*.py,**/pyproject.toml,**/requirements.txt",
        "description": "Python code style and patterns",
    },
    "database-design": {
        "alwaysApply": False,
        "globs": "**/*.sql,**/prisma/**/*,**/drizzle/**/*,**/migrations/**/*",
        "description": "Database schema and SQL patterns",
    },
    "testing-patterns": {
        "alwaysApply": False,
        "globs": "**/*.test.*,**/*.spec.*,**/__tests__/**/*,**/tests/**/*",
        "description": "Testing frameworks and patterns",
    },
    "mobile-design": {
        "alwaysApply": False,
        "globs": "**/App.tsx,**/app.json,**/*.native.*,**/android/**/*,**/ios/**/*",
        "description": "Mobile development for iOS/Android",
    },
}

# CURSOR SKILLS: On-demand toolkits invokable via slash commands (e.g., /plan)
# Map skill name to command/description
SKILLS_TOOLKIT_MAP = {
    "architecture": "discuss system architecture and design patterns",
    "brainstorming": "explore ideas and creative solutions",
    "plan-writing": "create implementation plans and roadmaps",
    "systematic-debugging": "debug issues and analyze errors",
    "code-review-checklist": "review code and ensure quality",
    "performance-profiling": "optimize performance and find bottlenecks",
    "security-scanner": "audit code for vulnerabilities",
    "seo-fundamentals": "optimize for search engines",
}

# Subagent descriptions — derived from central registry, with Cursor-specific fallback
from agent_bridge.core.agent_registry import get_agent_role as _get_cursor_role


def _get_cursor_agent_description(slug: str) -> str:
    role = _get_cursor_role(slug)
    if role:
        return role.description
    return f"Specialized assistant for {slug.replace('-', ' ')} activities"


# =============================================================================
# MDC FORMAT HELPERS
# =============================================================================


def generate_mdc_frontmatter(description: str = "", globs: str = "", always_apply: bool = False) -> str:
    """
    Generate MDC frontmatter for Cursor rules.
    """
    lines = ["---"]
    lines.append(f"description: {description}")
    lines.append(f"globs: {globs}")
    lines.append(f"alwaysApply: {str(always_apply).lower()}")
    lines.append("---")
    return "\n".join(lines)


def extract_metadata_from_content(content: str) -> Dict[str, Any]:
    """Extract metadata from markdown content."""
    metadata = {"name": "", "description": ""}

    # Check existing frontmatter
    fm_match = re.match(r"^---\n(.*?)\n---\n", content, re.DOTALL)
    if fm_match:
        try:
            existing = yaml.safe_load(fm_match.group(1))
            if existing and isinstance(existing, dict):
                metadata.update(existing)
        except (yaml.YAMLError, ValueError, TypeError):
            pass

    # Extract from H1
    h1_match = re.search(r"^#\s+(.+)$", content, re.MULTILINE)
    if h1_match and not metadata.get("name"):
        metadata["name"] = h1_match.group(1).strip()

    # Extract description from first paragraph after H1
    desc_match = re.search(r"^#\s+.+\n\n(.+?)(?:\n\n|\n#)", content, re.DOTALL)
    if desc_match and not metadata.get("description"):
        metadata["description"] = desc_match.group(1).strip()[:200]

    return metadata


# =============================================================================
# CONVERSION FUNCTIONS
# =============================================================================


def convert_agent_to_cursor(source_path: Path, dest_path: Path) -> bool:
    """Convert agent to Cursor Subagent markdown format."""
    try:
        content = source_path.read_text(encoding="utf-8")
        agent_slug = source_path.stem.lower()
        agent_name = agent_slug.replace("-", " ").title()

        # Cursor Subagents frontmatter
        description = _get_cursor_agent_description(agent_slug)

        lines = ["---"]
        lines.append(f"name: {agent_name}")
        lines.append(f"description: {description}")
        lines.append("---")

        # Remove existing frontmatter from content
        content_clean = re.sub(r"^---\n.*?\n---\n*", "", content, flags=re.DOTALL)

        output = "\n".join(lines) + f"\n\n{content_clean.strip()}{CREDIT_LINE}"

        dest_path.parent.mkdir(parents=True, exist_ok=True)
        dest_path.write_text(output, encoding="utf-8")
        return True
    except Exception as e:
        print(f"  Error converting agent {source_path.name}: {e}")
        return False


def convert_skill_to_cursor(source_dir: Path, rules_dest: Path, skills_dest: Path) -> bool:
    """Convert skill to either MDC Rule or Cursor Skill folder."""
    try:
        skill_name = source_dir.name
        skill_file = source_dir / "SKILL.md"
        if not skill_file.exists():
            return False

        content = skill_file.read_text(encoding="utf-8")
        content_clean = re.sub(r"^---\n.*?\n---\n*", "", content, flags=re.DOTALL)

        # Merge additional .md files
        for md_file in sorted(source_dir.glob("*.md")):
            if md_file.name != "SKILL.md":
                additional = md_file.read_text(encoding="utf-8")
                additional_clean = re.sub(r"^---\n.*?\n---\n*", "", additional, flags=re.DOTALL)
                content_clean += f"\n\n---\n\n{additional_clean}"

        # OPTION A: Convert to MDC Rule (Auto-attach)
        if skill_name in MDC_RULES_CONFIG:
            config = MDC_RULES_CONFIG[skill_name]
            frontmatter = generate_mdc_frontmatter(
                description=config["description"], globs=config["globs"], always_apply=config["alwaysApply"]
            )
            rules_dest.mkdir(parents=True, exist_ok=True)
            dest_file = rules_dest / f"{skill_name}.mdc"
            dest_file.write_text(f"{frontmatter}\n\n{content_clean.strip()}{CREDIT_LINE}", encoding="utf-8")
            return True

        # OPTION B: Convert to Cursor Skill (On-demand/Slash command)
        skill_folder = skills_dest / skill_name
        skill_folder.mkdir(parents=True, exist_ok=True)

        # Agent Skills spec: name must be lowercase alphanumeric + hyphens, max 64 chars
        normalized_name = re.sub(r"[^a-z0-9-]", "-", skill_name.lower())[:64].strip("-")

        # Try to extract description from skill content first
        desc_match = re.search(r"^(?:>|Description:|Purpose:)\s*(.+?)$", content_clean, re.MULTILINE | re.IGNORECASE)
        if desc_match:
            description = desc_match.group(1).strip()[:1024]
        else:
            description = SKILLS_TOOLKIT_MAP.get(skill_name, f"Expert toolkit for {skill_name.replace('-', ' ')}")

        skill_header = f"---\nname: {normalized_name}\ndescription: {description}\n---\n\n"
        (skill_folder / "SKILL.md").write_text(f"{skill_header}{content_clean.strip()}{CREDIT_LINE}", encoding="utf-8")

        # Copy other files to skill folder as resources
        for item in source_dir.iterdir():
            if item.name != "SKILL.md":
                if item.is_file():
                    shutil.copy2(item, skill_folder / item.name)
                elif item.is_dir():
                    shutil.copytree(item, skill_folder / item.name, dirs_exist_ok=True)

        return True
    except Exception as e:
        print(f"  Error converting skill {source_dir.name}: {e}")
        return False


def convert_workflow_to_cursor_skill(source_path: Path, skills_dest: Path) -> bool:
    """Convert a workflow to a Cursor Skill (slash command)."""
    try:
        content = source_path.read_text(encoding="utf-8")
        name = source_path.stem

        # Extract metadata
        metadata = extract_metadata_from_content(content)
        description = metadata.get("description") or f"Execute workflow for {name}"

        skill_folder = skills_dest / name
        skill_folder.mkdir(parents=True, exist_ok=True)

        # Normalize content for Cursor Skill
        content_clean = re.sub(r"^---\n.*?\n---\n*", "", content, flags=re.DOTALL)

        # Agent Skills spec: name must be lowercase alphanumeric + hyphens, max 64 chars
        normalized_name = re.sub(r"[^a-z0-9-]", "-", name.lower())[:64].strip("-")

        header = f"---\nname: {normalized_name}\ndescription: {description}\n---\n\n"
        (skill_folder / "SKILL.md").write_text(f"{header}{content_clean.strip()}{CREDIT_LINE}", encoding="utf-8")
        return True
    except Exception as e:
        print(f"  Error converting workflow {source_path.name}: {e}")
        return False


def create_project_instructions(dest_root: Path, source_root: Path) -> bool:
    """Create .cursor/rules/project-instructions.mdc from AGENTS.md or similar."""
    try:
        rules_dir = dest_root / ".cursor" / "rules"
        rules_dir.mkdir(parents=True, exist_ok=True)

        # Look for project instructions
        instruction_sources = [
            source_root / "AGENTS.md",
            source_root / ".agent" / "ARCHITECTURE.md",
            source_root / "CONTRIBUTING.md",
        ]

        content_parts = []
        for src in instruction_sources:
            if src.exists():
                content_parts.append(src.read_text(encoding="utf-8"))

        if content_parts:
            frontmatter = generate_mdc_frontmatter(
                description="Project-specific instructions and architecture guidelines",
                globs="",
                always_apply=True,  # Project instructions always apply
            )

            combined = "\n\n---\n\n".join(content_parts)
            output = f"{frontmatter}\n\n{combined}{CREDIT_LINE}"

            (rules_dir / "project-instructions.mdc").write_text(output, encoding="utf-8")
            return True

        return False
    except Exception as e:
        print(f"  Error creating project instructions: {e}")
        return False


def convert_to_cursor(source_root: Path, dest_root: Path, verbose: bool = True) -> Dict[str, Any]:
    """
    Main conversion function for Cursor v2.4+ format.
    """
    stats = {"agents": 0, "rules": 0, "skills": 0, "workflows": 0, "errors": [], "warnings": []}

    # Define paths
    agents_src = source_root / ".agent" / "agents"
    skills_src = source_root / ".agent" / "skills"
    workflows_src = source_root / ".agent" / "workflows"

    rules_dest = dest_root / ".cursor" / "rules"
    agents_dest = dest_root / ".cursor" / "agents"
    skills_dest = dest_root / ".cursor" / "skills"

    # Recreate output directories (preserve user files by only overwriting known outputs)
    for path in [rules_dest, agents_dest, skills_dest]:
        path.mkdir(parents=True, exist_ok=True)

    # 1. Convert Agents (Personas)
    if agents_src.exists():
        if verbose:
            print("Converting Agents to Cursor Subagents...")
        for agent_file in agents_src.glob("*.md"):
            dest_file = agents_dest / agent_file.name
            if convert_agent_to_cursor(agent_file, dest_file):
                stats["agents"] += 1
            else:
                stats["errors"].append(f"agent:{agent_file.name}")

    # 2. Convert Skills (Auto-rules or Slash-commands)
    if skills_src.exists():
        if verbose:
            print("Converting Skills to Cursor Rules/Skills...")
        for skill_dir in skills_src.iterdir():
            if skill_dir.is_dir():
                if convert_skill_to_cursor(skill_dir, rules_dest, skills_dest):
                    stats["skills"] += 1
                else:
                    stats["errors"].append(f"skill:{skill_dir.name}")

    # 3. Convert Workflows (Slash-commands)
    if workflows_src.exists():
        if verbose:
            print("Converting Workflows to Cursor Commands...")
        for workflow_file in workflows_src.glob("*.md"):
            if convert_workflow_to_cursor_skill(workflow_file, skills_dest):
                stats["workflows"] += 1
            else:
                stats["errors"].append(f"workflow:{workflow_file.name}")

    # 4. Create Project Instructions (Always-on MDC)
    if create_project_instructions(dest_root, source_root):
        if verbose:
            print("  ✓ project-instructions.mdc created")

    # 5. Run external skill plugins (declarative, config-driven via .agent/plugins.json)
    try:
        from agent_bridge.core.plugins import PluginRunner

        runner = PluginRunner(source_root)
        plugin_results = runner.run_for_ide("cursor", dest_root, verbose=verbose)
        for pname, pstatus in plugin_results.items():
            if pstatus == "ok":
                if verbose:
                    print(f"  ✓ Plugin '{pname}' installed")
            elif pstatus.startswith("error"):
                stats["warnings"].append(f"Plugin '{pname}': {pstatus}")
    except ImportError:
        pass

    if verbose:
        print("\nCursor v2.4 conversion complete!")
        print(f"  - Agents: {stats['agents']}")
        print(f"  - Rules (MDC): {len(list(rules_dest.glob('*.mdc'))) if rules_dest.exists() else 0}")
        print(f"  - Commands/Skills: {stats['skills'] + stats['workflows']}")
        if stats["errors"]:
            print(f"  Errors: {len(stats['errors'])}")

    return stats


